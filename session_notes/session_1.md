# Session 1 - FastAPI Hello World & Git Basics

**Date:** October 4, 2025
**Phase:** 1.1 - Setup & Hello World

---

## Commands Used

### Python/FastAPI Commands
- `pip3 list | grep -i fastapi` - Check if FastAPI is installed
- `pip3 install fastapi uvicorn` - Install FastAPI and uvicorn server
- `uvicorn main:app --reload` - Start FastAPI dev server with auto-reload
  - `main:app` = module:app_instance (file:variable)
  - `--reload` = Auto-restart on code changes
- `curl http://127.0.0.1:8000/` - Test API endpoint from command line

### Server Management Commands
- `lsof -i :8000` - Check what's running on port 8000
- `ps aux | grep uvicorn` - Find uvicorn processes
- `CTRL+C` - Stop server running in terminal

### Git Commands
- `git status` - Show working tree status (tracked/untracked/modified files)
- `git add <file>` - Stage files for commit (add to staging area)
- `git commit -m "message"` - Save staged changes with description
- `git log --oneline` - Show commit history in compact format
- `git log --oneline --decorate` - Show commit history with branch pointers

---

## Concepts Covered

### FastAPI Fundamentals
1. **FastAPI Class**: The main framework class that creates web applications
2. **App Instance**: `app = FastAPI()` creates an application object
3. **Route Decorators**: `@app.get("/")` maps HTTP methods to functions
   - `@app.get()` - Handle GET requests
   - First parameter is the path/endpoint
4. **Automatic JSON Conversion**: FastAPI auto-converts Python dicts → JSON responses
5. **ASGI Server (uvicorn)**:
   - FastAPI = framework (brain)
   - uvicorn = ASGI server (body that handles HTTP)
   - Can't run FastAPI with just `python3 main.py` - needs a server!

### Git Workflow
1. **Three States of Files**:
   - **Untracked**: Git sees them but doesn't manage them
   - **Staged**: In staging area, ready to commit (waiting room)
   - **Committed**: Snapshot saved permanently in history

2. **Git Workflow Steps**:
   ```
   1. Make changes → files are modified
   2. git add <file> → files staged
   3. git commit -m "msg" → snapshot saved
   ```

3. **Important Git Concepts**:
   - **HEAD**: Pointer showing current location in Git history
   - **main/master**: Primary branch (main line of development)
   - **origin/main**: Remote repository's main branch
   - **.gitignore**: File telling Git which files to ignore
     - `__pycache__/` - Python compiled bytecode (auto-generated)
     - `*.pyc` - Python cache files
     - `.claude/` - Tool settings

4. **Good Commit Messages**:
   - First line: Brief summary (what changed)
   - Blank line
   - Bullet points: Details (what and why)
   - Example:
     ```
     Add FastAPI Hello World endpoint

     - Create basic GET endpoint at root path
     - Add .gitignore for Python cache files
     - First working FastAPI application
     ```

---

## Code Written

### main.py
```python
# Import the FastAPI class from fastapi library
from fastapi import FastAPI

# Create an instance of FastAPI application
app = FastAPI()

# Route decorator: handles GET requests at root endpoint "/"
@app.get("/")
def read_root():
    # FastAPI auto-converts Python dict to JSON response
    return {"message": "Hello World"}
```

### .gitignore
```
# Python cache files
__pycache__/
*.pyc
*.pyo

# Virtual environment (if we create one later)
venv/
env/

# Claude Code settings
.claude/
```

---

## Quiz Questions & Answers

### Q1: What does this code return and in what format?
```python
@app.get("/")
def read_root():
    return {"message": "Hello World"}
```
**Answer:** Returns a Python dictionary `{"message": "Hello World"}`, but FastAPI automatically converts it to JSON format `{"message":"Hello World"}` for the HTTP response.

---

### Q2: Why doesn't `python3 main.py` work for running FastAPI?
**Answer:** Because FastAPI is just a framework that defines routes and handles requests. You need an ASGI server (like uvicorn) to actually listen for HTTP requests and run the application. Think of it as: FastAPI = brain, uvicorn = body.

---

### Q3: What's the difference between untracked, staged, and committed files?
**Answer:**
- **Untracked**: Git sees them but doesn't track changes
- **Staged**: Files in the staging area, ready to be committed (waiting room)
- **Committed**: Snapshot permanently saved in Git history, can go back anytime

---

### Q4: Why shouldn't `__pycache__/` be committed to Git?
**Answer:**
- Auto-generated by Python when code runs
- Machine/version specific (different OS/Python versions create different bytecode)
- Redundant (everyone generates their own when running code)
- Clutters repository with non-source files

---

### Q5: If we change `@app.get("/")` to `@app.get("/hello")`, what URL do we use?
**Answer:** `http://127.0.0.1:8000/hello` - the route path changes in the URL.

---

### Q6: What is HEAD in Git?
**Answer:** HEAD is a pointer that shows "where you are right now" in Git. It usually points to the latest commit on your current branch. Like a bookmark saying "you are here."

---

### Q7: What does `curl` do?
**Answer:** `curl` (Client URL) is a command-line tool to make HTTP requests. It's like a browser but in the terminal - used to test APIs and fetch web content.

---

## Git Workflow This Session

### Commits Made:
1. **Initial commit** (`a386415`) - Repository creation
2. **Add FastAPI Hello World endpoint** (`26d020a`) - Our first feature
   - Added `main.py` with Hello World endpoint
   - Added `.gitignore` for Python cache files

### Branch Operations:
- Working on `main` branch
- HEAD points to latest commit (`26d020a`)
- Remote (`origin/main`) is one commit behind (needs push)

### Best Practices Demonstrated:
1. ✅ Check `git status` before adding files
2. ✅ Use `.gitignore` to exclude generated files
3. ✅ Write descriptive commit messages
4. ✅ Commit after each working feature
5. ✅ Use `git log` to review history

---

## Key Takeaways

1. **FastAPI Magic**: Automatically converts Python types to JSON
2. **Server vs Framework**: FastAPI needs uvicorn to run
3. **Git Three-Step**: modify → add → commit
4. **Clean Repo**: Use .gitignore for generated files
5. **Good Commits**: Describe what and why, not just what

---

## Next Session Preview

**Phase 1.2: Path Parameters**
- Dynamic routes (e.g., `/users/{user_id}`)
- URL parameter extraction
- Type validation
- Git branching practice

---

**Commands to Review Before Next Session:**
- How to create a Git branch
- How to switch between branches
- Basic variable routing in web frameworks
